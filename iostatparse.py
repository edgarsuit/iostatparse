#!/usr/local/bin/python3
#
# iostatparse.py
#
# usage: iostatparse.py [-h] [-l] file
#
# Parse the output of zpool iostat to generate summarized performance statistics
#
# Positional arguments:
#  file 		Text file containing the zpool iostat output to parse
#
# Optional arguments:
#  -l 			Parse latency statistics from zpool iostat -l
#
# Details:
# Outputs 50th, 90th, 95th, 99th percentile and max value for performance statistics generated by zpool iostat command.
# Performance statistics include R/W/Combined IOPS and throughput, total R/W latency, and disk R/W latency. Also
# calculates R/W mix, average I/O size, total data written across iostat interval, and average total written per day.
#
# Copyright 2020 Jason Rose <jason@jro.io>
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
# following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following
#    disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
#    following disclaimer in the documentation and/or other materials provided with the distribution
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import argparse
import re
import math

def IOStatParse(file, l):
	# Track line count
	ln = 0

	# Initialize arrays for storing each type of data
	read_iops_raw = []
	write_iops_raw = []
	both_iops_raw = []
	read_tp_raw = []
	write_tp_raw = []
	both_tp_raw = []
	io_size = []

	# Initialize latency arrays if l flag is passed
	if l:
		read_tot_wait_raw = []
		write_tot_wait_raw = []
		read_disk_wait_raw = []
		write_disk_wait_raw = []
		l_err = False

	# Initialize array to hold all the raw data
	iostat = []

	# RegExp for removing header rows
	h1 = '\s+capacity\s+operations\s+bandwidth'
	h2 = 'pool\s+alloc\s+free'

	# Remove empty lines and header lines from output file, transfer file to array
	f = open(file,"r")
	for line in f:
		if (not line.isspace()) and ("---" not in line) and not re.search(h1,line) and not re.search(h2,line):
			iostat.append(line)

	# Close iostat file, all data is in array
	f.close()

	# Walk through all data in output array
	for line in iostat:
		#  Split the data
		data = line.split()

		# Pull out read ops data. Multiply by 1000 if "K" in value
		read = data[3]
		if "K" in read:
			read = int(float(read[:-1])*1000)
		read_iops_raw.append(int(read))

		# Pull out write ops data. Multiply by 1000 if "K" in value
		write = data[4]
		if "K" in write:
			write = int(float(write[:-1])*1000)
		write_iops_raw.append(int(write))

		# Add read and write value to give R+W value
		both_iops_raw.append(int(read) + int(write))

		# Pull out read TP data. Multiply by 1024 if "K", 1024^2 if "M", 1024^3 if "G" in value
		readtp = data[5]
		if "G" in readtp:
			readtp = int(float(readtp[:-1])*pow(1024,3))
		elif "M" in readtp:
			readtp = int(float(readtp[:-1])*pow(1024,2))
		elif "K" in readtp:
			readtp = int(float(readtp[:-1])*1024)
		read_tp_raw.append(int(readtp))

		# Pull out write TP data. Multiply by 1024 if "K", 1024^2 if "M", 1024^3 if "G" in value
		writetp = data[6]
		if "G" in writetp:
			writetp = int(float(writetp[:-1])*pow(1024,3))
		elif "M" in writetp:
			writetp = int(float(writetp[:-1])*pow(1024,2))
		elif "K" in writetp:
			writetp = int(float(writetp[:-1])*1024)
		write_tp_raw.append(int(writetp))

		# Add read and write value to give R+W value
		both_tp_raw.append(int(readtp) + int(writetp))

		# Try to determine avg IO size by adding up all TP and dividing by all ops.
		# Operation can fail if no ops during that second (div by zero), so pass on
		# any errors
		try:
			io_size.append( (int(readtp) + int(writetp)) / (int(read) + int(write)) )
		except:
			pass

		# Gather latency data if -l flag is passed
		if l:
			try:
				# Pull total read wait, convert to nSec
				read_tot_wait = data[7]
				if "-" not in read_tot_wait:
					if "ms" in read_tot_wait:
						read_tot_wait = int(read_tot_wait[:-2])*1000000
					elif "us" in read_tot_wait:
						read_tot_wait = int(read_tot_wait[:-2])*1000
					elif "ns" in read_tot_wait:
						read_tot_wait = int(read_tot_wait[:-2])
					read_tot_wait_raw.append(read_tot_wait)

				# Pull total write wait, convert to nSec
				write_tot_wait = data[8]
				if "-" not in write_tot_wait:
					if "ms" in write_tot_wait:
						write_tot_wait = int(write_tot_wait[:-2])*1000000
					elif "us" in write_tot_wait:
						write_tot_wait = int(write_tot_wait[:-2])*1000
					elif "ns" in write_tot_wait:
						write_tot_wait = int(write_tot_wait[:-2])
					write_tot_wait_raw.append(write_tot_wait)

				# Pull disk read wait, convert to nSec
				read_disk_wait = data[8]
				if "-" not in read_disk_wait:
					if "ms" in read_disk_wait:
						read_disk_wait = int(read_disk_wait[:-2])*1000000
					elif "us" in read_disk_wait:
						read_disk_wait = int(read_disk_wait[:-2])*1000
					elif "ns" in read_disk_wait:
						read_disk_wait = int(read_disk_wait[:-2])
					read_disk_wait_raw.append(read_disk_wait)

				# Pull disk write wait, convert to nSec
				write_disk_wait = data[9]
				if "-" not in write_disk_wait:
					if "ms" in write_disk_wait:
						write_disk_wait = int(write_disk_wait[:-2])*1000000
					elif "us" in write_disk_wait:
						write_disk_wait = int(write_disk_wait[:-2])*1000
					elif "ns" in write_disk_wait:
						write_disk_wait = int(write_disk_wait[:-2])
					write_disk_wait_raw.append(write_disk_wait)

			# If -l was passed but the extra latency columns are not present, bail on the
			# rest of the latency tracking/stats calculations
			except:
				l_err = True
				l = False

		# Increment line number
		ln+=1

		# Print parse status every 100K lines (longer files can take a while to parse)
		if (ln) % 100000 == 0:
			print("Parsing line " + format(ln,",d") + "...")

	# Print sample count
	print("\nTotal samples parsed: " + format(ln,",d") + "\n")

	# Percentile function requires data lists to be sorted
	read_iops_raw = sorted(read_iops_raw)
	write_iops_raw = sorted(write_iops_raw)
	both_iops_raw = sorted(both_iops_raw)
	read_tp_raw = sorted(read_tp_raw)
	write_tp_raw = sorted(write_tp_raw)
	both_tp_raw = sorted(both_tp_raw)

	# Sort latency values if we're
	if l:
		read_tot_wait_raw = sorted(read_tot_wait_raw)
		write_tot_wait_raw = sorted(write_tot_wait_raw)
		read_disk_wait_raw = sorted(read_disk_wait_raw)
		write_disk_wait_raw = sorted(write_disk_wait_raw)

	# Calculate 50P, 90P, 95P, 99P and max value for R/W/R+W IOPS and TP, put them in an array along with label
	# for printing via tabulate function
	ReadIOPS = ["Read ","IOPS",
		str(int(percentile(read_iops_raw,.50))),
		str(int(percentile(read_iops_raw,.90))),
		str(int(percentile(read_iops_raw,.95))),
		str(int(percentile(read_iops_raw,.99))),
		str(max(read_iops_raw))]
	WriteIOPS = ["Write ","IOPS",
		str(int(percentile(write_iops_raw,.50))),
		str(int(percentile(write_iops_raw,.90))),
		str(int(percentile(write_iops_raw,.95))),
		str(int(percentile(write_iops_raw,.99))),
		str(max(write_iops_raw))]
	BothIOPS = ["R+W ","IOPS",
		str(int(percentile(both_iops_raw,.50))),
		str(int(percentile(both_iops_raw,.90))),
		str(int(percentile(both_iops_raw,.95))),
		str(int(percentile(both_iops_raw,.99))),
		str(max(both_iops_raw))]

	# Multiply all TP values by 1024^2 and append with "M" to indicate megabytes/sec units
	ReadTP = ["Read ","TP",
		str(round(int(percentile(read_tp_raw,.50))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(read_tp_raw,.90))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(read_tp_raw,.95))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(read_tp_raw,.99))/pow(1024,2),1)) + " MiB",
		str(round(max(read_tp_raw)/pow(1024,2),1)) + " MiB"]
	WriteTP = ["Write ","TP",
		str(round(int(percentile(write_tp_raw,.50))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(write_tp_raw,.90))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(write_tp_raw,.95))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(write_tp_raw,.99))/pow(1024,2),1)) + " MiB",
		str(round(max(write_tp_raw)/pow(1024,2),1)) + " MiB"]
	BothTP = ["R+W ","TP",
		str(round(int(percentile(both_tp_raw,.50))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(both_tp_raw,.90))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(both_tp_raw,.95))/pow(1024,2),1)) + " MiB",
		str(round(int(percentile(both_tp_raw,.99))/pow(1024,2),1)) + " MiB",
		str(round(max(both_tp_raw)/pow(1024,2),1)) + " MiB"]

	# All latency values are in nSec, divide by 1M to convert to mS
	if l:
		ReadTotWait = ["Read ","Tot. Wait",
			str(round(percentile(read_tot_wait_raw,.50)/1000000,4)) + " mS",
			str(round(percentile(read_tot_wait_raw,.90)/1000000,4)) + " mS",
			str(round(percentile(read_tot_wait_raw,.95)/1000000,4)) + " mS",
			str(round(percentile(read_tot_wait_raw,.99)/1000000,4)) + " mS",
			str(round(max(read_tot_wait_raw)/1000000,4)) + " mS"]
		WriteTotWait = ["Write ","Tot. Wait",
			str(round(percentile(write_tot_wait_raw,.50)/1000000,4)) + " mS",
			str(round(percentile(write_tot_wait_raw,.90)/1000000,4)) + " mS",
			str(round(percentile(write_tot_wait_raw,.95)/1000000,4)) + " mS",
			str(round(percentile(write_tot_wait_raw,.99)/1000000,4)) + " mS",
			str(round(max(write_tot_wait_raw)/1000000,4)) + " mS"]
		ReadDiskWait = ["Read ","Tot. Wait",
			str(round(percentile(read_disk_wait_raw,.50)/1000000,4)) + " mS",
			str(round(percentile(read_disk_wait_raw,.90)/1000000,4)) + " mS",
			str(round(percentile(read_disk_wait_raw,.95)/1000000,4)) + " mS",
			str(round(percentile(read_disk_wait_raw,.99)/1000000,4)) + " mS",
			str(round(max(read_disk_wait_raw)/1000000,4)) + " mS"]
		WriteDiskWait = ["Write ","Tot. Wait",
			str(round(percentile(write_disk_wait_raw,.50)/1000000,4)) + " mS",
			str(round(percentile(write_disk_wait_raw,.90)/1000000,4)) + " mS",
			str(round(percentile(write_disk_wait_raw,.95)/1000000,4)) + " mS",
			str(round(percentile(write_disk_wait_raw,.99)/1000000,4)) + " mS",
			str(round(max(write_disk_wait_raw)/1000000,4)) + " mS"]

	# Formatting for stats table
	headers = ['','','50p','90p','95p','99p','Max']
	if not l:
		row_format = "{:>7}" + "{:<7}" + "{:<15}" * 5
	else:
		# Text in the row headers for latency values are longer, so use different formatting
		row_format = "{:>7}" + "{:<12}" + "{:<15}" * 5

	# Print the stats table
	print(row_format.format(*headers))
	print(row_format.format(*ReadIOPS))
	print(row_format.format(*WriteIOPS))
	print(row_format.format(*BothIOPS))
	print(row_format.format(*ReadTP))
	print(row_format.format(*WriteTP))
	print(row_format.format(*BothTP))

	# Print latency stats if l flag is passed
	if l:
		print(row_format.format(*ReadTotWait))
		print(row_format.format(*WriteTotWait))
		print(row_format.format(*ReadDiskWait))
		print(row_format.format(*WriteDiskWait))

	# Calculate and print other misc. stats
	tot_io = sum(read_iops_raw) + sum(write_iops_raw)
	print()
	print("  Read Mix: " + str(int(sum(read_iops_raw)/tot_io*100)) + "%")
	print("  Average IO size: " + str(round(sum(io_size)/len(io_size)/1000)) + " K")
	print("  Total written: " + str(round(sum(write_tp_raw)/(1000**4),1)) + " T")
	print("  Total written per day: " + str(round(sum(write_tp_raw)/(1000**4)/((ln)/86400),1)) + " T\n")

	# If there was an error finding latency values, report it
	if l_err:
		print("  NOTE: Could not find latency values in iostat output file. Did you run iostat with -l flag?\n")

def percentile(N, percent, key=lambda x:x):
	# Find the percentile of a list of values
 	# N is a list of values (N must already sorted)
	# percent is a float value from 0.0 to 1.0
	# parameter key - optional key function to compute value from each element of N

	if not N:
		return None
	k = (len(N)-1) * percent
	f = math.floor(k)
	c = math.ceil(k)
	if f == c:
		return key(N[int(k)])
	d0 = key(N[int(f)]) * (c-k)
	d1 = key(N[int(c)]) * (k-f)
	return d0+d1

if __name__ == '__main__':
	parser = argparse.ArgumentParser(
		description="Parse the output of zpool iostat to generate summarized performance statistics")
	parser.add_argument('-l', action="store_true", help="Parse latency statistics from zpool iostat -l")
	parser.add_argument("file", help="Text file containing the zpool iostat output to parse")
	args = parser.parse_args()

	IOStatParse(args.file,args.l)
